## 4. 아키텍처
- MySQL 서버는 **엔진과 스토리지 엔진**으로 구분된다.
![mysql 전체구조](./images/mysql_structure.png)
- MySQL 엔진은 클라이언트의 접속 및 쿼리 요청을 처리하는 `커넥션 핸들러`, 최적화된 실행을 위한 `옵티마이저로` 구성된다.
- MySQL 엔진이 SQL 문장을 분석하고 최적화하는 두뇌라면 실제 데이터를 읽어오는 역할은 `스토리지 엔진`이 한다.

#### 4.1.2 MySQL 스레딩 구조
![mysql 스레딩구조](images/MySQL_%EC%8A%A4%EB%A0%88%EB%94%A9%EA%B5%AC%EC%A1%B0.png)
- MySQL 서버는 스레드 기반으로 동작하며 `포그라운드`와 `백그라운드` 스레드로 구분된다.
- 포그라운드 스레드는 최소 접속된 클라이언트 수만큼 존재하며 각 사용자가 요청하는 쿼리를 처리한다.
- 포그라운드 스레드는 데이터를 MySQL의 데이터 버퍼나 캐시로부터 가져오며 버퍼나 캐시에 없는 경우 스토리지 엔진에
따라 직접 가져오거나 백그라운드 스레드가 처리해준다.
- MyISAM 스토리지 엔진은 해당이 없지만 InnoDB 스토리지 엔진의 경우 여러 작업들이 백그라운드 스레드로 처리된다.
- 일반적인 DBMS는 쓰기 작업을 버퍼링해서 일괄처리하며 InnoDB도 이렇게 처리한다.

#### 4.1.3 메모리 할당 및 사용구조
- MySQL에서 사용되는 메모리 공간은 크게 `글로벌과 로컬 메모리 영역`으로 구분된다.
- `글로벌 메모리 영역`은 클라이언트 스레드 수와 무관하게 `하나의 메모리 공간만 할당되며 모든 스레드에 의해 공유`된다.
아래와 같은 **글로벌 메모리 영역**들이 있다.
  - 테이블 캐시
  - InnoDB 버퍼 풀
  - InnoDB 어댑티브 해시 인덱스
- 로컬 메모리 영역은 클라이언트 스레드가 쿼리를 처리하는데 사용하는 메모리 영역으로 대표적으로 커넥션 버퍼와 정렬 버퍼가 있다.
- MySQL 서버는 클라이언트 요청을 처리하기 위해 스레드를 하나씩 할당하게 되고 로컬 메모리는 각 클라이언트 스레드별로
독립적으로 할당되며 공유되지 않는다는 특징이 있다.
- 대표적인 **로컬 메모리 영역**은 다음과 같다.
  - 정렬 버퍼
  - 조인 버퍼
  - 바이너리 로그 캐시
  - 네트워크 버퍼

#### 4.1.4 플러그인 스토리지 엔진 모델
- MySQL의 독특한 구조 중 대표적인 것이 플러그인 모델로 다른 회사나 사용자가 직접 스토리지 엔진을 개발하는 것도 가능하다.
- MySQL에서 MyISAM, InnoDB와 같이 다른 스토리지 엔진에 쿼리를 실행하더라도 MySQL 엔진의 처리내용은 비슷하며
단순히 데이터 읽기/쓰기 방식이 차이가 있다. 실질적인 GROUP BY나 ORDER BY등의 복잡한 처리는 스토리지 엔진 영역이
아니라 MySQL 엔진의 처리 영역인 `쿼리 실행기`에서 처리된다.

#### 4.1.5 컴포넌트
- MySQL 8.0 부터 기존 플러그인 아키텍처의 단점을 보완하기 위해 컴포넌트 아키텍처가 지원된다. 플러그인의 단점은
  - 플러그인은 오직 MySQL 서버와 인터페이스 할 수 있고 플러그인들끼리 통신할 수 없음
  - 플러그인 상호 의존관계를 설정할 수 없어 관리가 어려움

#### 4.1.6 쿼리 실행구조
- 쿼리를 실행하는 관점에서 MySQL 구조는 아래와 같이 나눌 수 있다.
![쿼리 실행구조](./images/%EC%BF%BC%EB%A6%AC%EC%8B%A4%ED%96%89%EA%B5%AC%EC%A1%B0.png)
- **쿼리파서** (쿼리 문장을 분해해 트리 형태의 구조로 만들어내는 작업, 문법 오류는 이과정에서 발견됨)
- **전처리기** (각 테이블의 존재여부 및 권한 확인)
- **옵티마이저** (들어온 쿼리를 어떻게 가장 빠르게 처리할지를 결정하는 역할)
- **실행 엔진** (핸들러에게 요청해서 받은 결과를 연결하는 역할)
- **핸들러** (스토리지 엔진, 실행엔진 요청에 따라 디스크에 저장하고 읽어온다.)

#### 4.1.8 캐시
- 쿼리 캐시가 성능 저하와 많은 버그로 인해 MySQL 8.0 부터 **쿼리 캐시는 기능에서 제거**되었다.

### 4.2 InnoDB 스토리지 엔진 아키텍처
- InnoDB는 MySQL에서 사용하는 스토리지 엔진 중 유일하게 레코드 기반의 잠금을 제공하며 그 때문에 높은 동시성 처리가
가능하고 안정적이며 성능이 뛰어나다.
- 아래 그림은 InnoDB 아키텍처를 간단히 보여주는데 각 특징들을 하나씩 살펴보자
![InnoDB 구조](./images/innodb_구조.png)

#### 4.2.1 프라이머리 키에 의한 클러스터링
- InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링 되어 저장된다.
- 즉 프라이머리 키 값의 순서대로 디스크에 저장되며 모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키값을
논리적인 주소로 사용한다. 프라이머리 키가 클러스터링 인덱스이기 때문에 프라이머리 키를 이용한 레인지 스캔은
상당히 빨리 처리될 수 있다.
- 결과적으로 쿼리 실행계획에서 `프라이머리 키`는 다른 보조 인덱스에 비해 **높은 우선순위**를 가지게 될 확률이 높다.

#### 4.2.2 외래 키 지원
- 외래키는 InnoDB 스토리지 엔진 레벨에서 지원하는 기능이지만 **서버 운영의 불편함으로 실무에서는 사용하지 않는 경우**가 많다.
- InnoDB에서 외래키는 부모/자식 테이블 모두 해당 컬럼에 인덱스를 생성하고, 변경시 부모/자식 테이블에 데이터가 있는지 체크하는 작업이 필요하므로 잠금이 여러 테이블로 전파되고 그로인한 데드락이 발생할 때가 있으니 주의해야 한다.
- 또한 수동으로 데이터에 쓰기 작업을 할 때 부모/자식 테이블 관계를 명확히 파악하지 못하면 작업이 실패할 수도 있다.
- 특히 긴급하게 조치를 해야할 경우 더욱 문제가 될 수 있다.

#### 4.2.3 MVCC (Multi Version Concurrency Control)
- `MVCC`의 가장 큰 목적은 `잠금을 사용하지 않는 일관된 읽기`를 제공하는데 있다. InnoDB는 Undo Log(언두 로그)를
이용해 이 기능을 구현한다.
- 여기서 `멀티 버전`이라 함은 하나의 레코드에 여러개의 버전이 동시에 존재한다는 의미다.
- 예를 들어 `insert` 쿼리로 데이터를 쓰고 `update` 쿼리로 데이터를 변경한다고 가정하자. `update` 쿼리가 아직 `commit이나`
`rollback`이 되기전에 해당 데이터를 조회하면 원본 데이터가 조회될까? 아니면 메모리상에 수정된 데이터가 조회될까?
- 결과는 MySQL 서버에 설정된 `격리 수준(Isolation Level)`에 따라 다르다. 격리수준이 `READ_UNCOMMITED`인 경우 메모리상에
수정된 데이터를 읽어서 반환하는 반면 `READ_COMMITED`나 그 이상의 격리수준인 경우 아직 `commit` 되지 않았기 때문에 변경되기
이전 데이터를 보관하는 undo 영역의 데이터를 반환환다.
- 이렇게 하나의 레코드에 대해 여러 버전을 유지하는 것을 `MVCC`라고 표현한다.

#### 4.2.4 잠금없는 일관된 읽기 (Non-Locking Consistent READ)
- InnoDB 스토리지 엔진은 `MVCC` 기술을 이용해 잠금을 걸지 않고 읽기 작업을 수행한다. 즉, 다른 트랜잭션의 변경 작업과
관계없이 항상 잠금을 대기하지 않고 바로 실행된다.
- 예를 들어 특정 사용자가 레코드를 변경하고 아직 커밋을 수행하지 않았다 하더라도 이 트랜잭션이 다른 사용자의 `SELECT`
작업을 방해하지 않는다.
- 이를 잠금없는 일관된 읽기라고 표현하며 InnoDB에서는 변경되기 전의 데이터를 읽기 위해 언두 로그를 사용한다.

#### 4.2.5 자동 데드락 감지
- InnoDB 스토리지 엔진은 내부적으로 `데드락`을 감지해 주기적으로 하나를 강제 종료한다. 이때 어느 트랜잭션을 종료할지
판단 기준은 트랜잭션의 언두 로그 양이며, 언두 로그가 적을수록 롤백을 해도 언두처리를 해야 할 내용이 적다는 뜻이다.
- 동시 처리량이 증가하거나 잠금 개수가 많아지면 데드락 감지 스레드가 느려지는데 이를 위해 MySQL 서버는
`innodb-deadlock_detect` 변수를 제공하며 OFF일 경우 데드락 감지 스레드는 작동하지 않게 된다.
- 또한 `innodb-lock-wait-timeout` 시스템 변수를 활성화하면 데드락 상황에서 일정시간이 지나면 자동으로 요청이 실패하도록
할 수 있다. 따라서 `innodb-deadlock_detect` 변수가 OFF인 상황이라면 `innodb-deadlock_detect` 변수르 기본값보다 낮게 설정해서 사용할 것을 권한다.

#### 4.2.7 InnoDB 버퍼 풀
- InnoDB 스토리지 엔진에서 가장 핵심적인 부분으로 데이터나 인덱스 정보를 메모리에 **캐시해두는** 공간이다.
- 쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할도 같이 한다.

#### 4.2.9 언두 로그
- InnoDB 스토리지 엔진은 트랜잭션과 격리 수준을 보장하기 위해 데이터가 변경되기 전 이전 버전의 데이터를 별도로 백업한다.
- 이렇게 백업된 데이터를 `Undo Log`라고 하는데 어떻게 사용되는지 간단히 살펴보면
  - **트랜잭션 보장**
    - 트랜잭션이 롤백되면 변경전 데이터로 복구해야 하는데, 이때 언두 로그에 백업해둔 이전 버전의 데이터를 이용해 복구
  - **격리 수준보장**
    - 특정 커넥션에서 데이터를 변경하는 도중 다른 커넥션에서 데이터를 조회하면 트랜잭션 격리 수준에 맞게 언두 로그에 백업해둔 데이터를 읽어서 반환하기도 한다.

#### 4.2.11 리두 로그
- MySQL 서버가 SW/HW 적인 문제로 비정상 종료되었을 때 데이터 파일에 기록하지 못한 데이터를 잃지 않기 위한 안전장치로 `리두 로그`를 사용한다.
- MySQL 서버를 포함한 DB 서버는 데이터 변경 내용을 로그로 먼저 기록한다. 모든 DBMS는 읽기 성능을 고려한 자료구조를
가지고 있기 때문에 데이터 파일 쓰기는 디스크의 랜덤 엑세스가 필요하다.
- 따라서 데이터 쓰기는 상대적으로 큰 비용이 필요한데 이로 인한 성능저하를 마기 위해 쓰기 비용이 낮은 자료 구조를 가진
리두 로그를 가지고 있으며 비정상 종료시, 리두 로그의 내용을 이용해 데이터를 서버가 종료되기 직전 상태로 복구한다.

#### 4.2.13 InnoDB와 MyISAM, MEMEORY 스토리지 엔진 비교
- MySQL 5.5 부터는 InnoDB 스토리지 엔진이 기본 스토리지 엔진으로 채택됐지만 시스템 테이블은 여전히 MyISAM 테이블을 사용했다.
- MySQL 8.0 부터는 기존 MyISAM이 지원하던 특정기능을 InnoDB가 모두 지원하게 되서 이후 버전에서는 MyISAM 스토리지 엔진은 없어질 것으로 예상된다.
- MyISAM이나 MEMORY 스토리지 엔진의 장점은 MySQL 5.x 버전이라면 의미가 있는 비교겠지만 8.0에서는 더이상 무의미한
비교이고 8.0 버전에서는 MySQL의 모든 기능이 InnoDB 스토리지 엔진 기반으로 재편됐다.
