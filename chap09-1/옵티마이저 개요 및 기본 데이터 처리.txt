9 - 1 개요

1. 실행절차

	1) 문장을 잘게 쪼개서(SQL 파싱) 서버가 이해할 수 있는 수준으로 분리(SQL 파서 모듈로 처리). 모듈로 처리한 쿼리(SQL 파스트리)로 실행. MySQL 엔진에서 처리
		- 문장오류 걸러내는 단계
	2) SQL 파스트리를 참조하며 서버의 옵티마이저에서 처리된다. MySQL 엔진에서 처리
		- 불필요하거나 복잡한 조건&연산 제거 및 단순화
		- 조인한 테이블 읽기순서 결정
		- 테이블 조건과 인덱스 통계 정보를 기반으로 사용할 인덱스 결정
		- 임시테이블에 레코드넣고 재가공 결정여부 판단
		등등..
		을 통해 실행계획 생성
	3) 	스토리지 엔진(레코드를 MySQL엔진에 전달)& MySQL 엔진(받은 레코드 조인 및 정렬)에서 동시처리
	
2. 옵티마이저 종류
	1) 비용기반 최적화(CBO) - 현재 대부분 사용
		- 여러 가지 방법을 만들어서 각 방법에 대한 실행 계획별 비용산출. 최소비용이 드는 방식을 선택해 쿼리 실행.
	2) 규칙 기반 최적화(RBO) - 옛날에 많이 사용
		- 옵티마이저에 내장된 우선순위만 따라서 실행 계획 수립.


9 - 2 기본 데이터 처리

1. 풀 테이블 스캔 & 풀 인덱스 스캔
	
	1) 풀 테이블 스캔
		- 옵티마이저 실행조건
			* 테이블 페이지가 1개로 구성될 정도로 레코드 건수가 작아 인덱스를 통해 읽을 필요가 없는경우
			* 조건절이나 ON절에 인덱스를 이용할만한 조건이 없는경우
			* 옵티마이저가 판단했을때 조건이 일치하는 레코드 건수가 너무 많을때 (인덱스의 B_Tree 샘플링 기반)
		- 풀 스캔을 하기 때문에 디스크로부터 페이지를 하나씩 읽어온다고 생각하나 MySQL(InnoDB)은 아니다.
			리드 어헤드작업을 이용해 다르게 처리.
			* 리드 어헤드 : 요청이 오기 전에 특정영역 데이터의 사용을 예측하고 미리 디스크에서 InnoDB의 버퍼풀에 데이터를 가져다 두는 것.
			* 포그라운드 스레드(=클라이언트 스레드)를 통해 먼저 페이지 읽기 실행
			* 특정 시점부터 백그라운드 스레드로 읽기작업을 넘긴다.
			* 이때 4,,,8,,, 최대64페이지까지 데이터 페이지 읽는 수를 증가시켜 버퍼풀에 저장
			* 보통은 디폴트 설정 그대로 사용하나 데이터 웨어하우스 용으로 사용한다면
			   리드 어헤드가 빨리 시작하게 innodb_read_ahead_threshold 시스템 변수의 옵션을 낮은 값으로 설정하자.
	
	2) 풀 인덱스 스캔
		- 풀 인덱스 스캔에서 동일하게 리드 어헤드 사용.
		- 인덱스는 테이블의 2~3개 칼럼만으로 구성하는 게 평균 > 테이블 자체보다 적은 용량으로 처리가 매우 빠름
		 ( 고로 단순한 쿼리라서 풀 테이블 스캔을 예상해도 실제로는 풀 인덱스를 스캔할 가능성이 높다.)
		
		- 풀 인덱스를 활용하지 못하는 경우
			: 레코드에만 있는 칼럼이 필요한 쿼리의 경우 (SELECT * 같은)

2. 병렬 처리 (8.0 버전~)
	- 1쿼리n스레드 처리하는데 innodb_read_ahead_threshold 시스템 변수를 통해 n을 얼마나 줄지 설정한다.
	- 조건없이 테이블의 전체 건수를 가져오는 쿼리도 병렬처리 가능
	- 그러나 CPU의 코어 수 < 병렬 처리용 스레드 수 ==> 성능떨어지니 주의. 
	- 고로 n < CPU 코어 수
	
	1. ORDER BY 처리
		1) 인덱스 이용
			- 장점 : INSERT, UPDATE, DELETE 실행시 유리. (이미 인덱스가 정렬되어 있어 순서대로 읽기때문 > 빠르다)
			- 단점 : 부가적인 인덱스 추가/삭제 작업때문에 느리고 인덱스 공간때문에 디스크 공간을 더 잡아먹고 메모리가 많이 필요함.
			- 인덱스를 이용할 수 없는 경우
				: 정렬 기준이 많아서 요건별로 인덱스생성 불가할 때
				: GROUP BY & DISTINCT 처리를 정렬해야할 때
				: UNION 결과(임시테이블 결과)를 다시 정렬할 때
				: 랜덤하게 결과 레코드 가져와야 할때
		2) Filesort 이용
			- 장점 : 정렬할 레코드가 별로 없는경우 처리속도가 빠름. (인덱스를 생성하지 않아도 되기 때문에)
			- 단점 : 쿼리 실행시 이용하기 때문에 레코드가 많으면 느리다.
			- USING FILESORT 메시지 : 인덱스 이용X. 별도의 정렬 처리를 수행한 경우 표시되는 메시지. 실행계획의 XTRA칼럼에 표시
			
		3) 소트 버퍼
			- 정렬을 수행하기 위한 별도의 메모리 공간. 쿼리 실행이 완료되면 시스템으로 반납된다.
			- SORT_BUFFER_SIZE 시스템 변수 : 최대 사용 가능한 소트 버퍼 공간 설정하는 변수
			- 정렬해야하는 레코드 건수 > 소트 버퍼로 할당된 공간 인 경우
				: 레코드를 여러 조각으로 나눠 처리. 이때 디스크를 사용해 임시 저장을 한다.
			- 순서 (이 병합과정을 멀티 머지라고 한다. 이때 상태 변수에 멀티 머지 횟수를 누적해서 집계한다)
				(1) 별도 메모리에서 정렬 수행
				(2) 디스크에 임시 기록
				(3) 레코드 가져와서 재정렬 > 디스크에 임시 저장 반복
				(4) 각 버퍼 크기에 맞게 정렬된 레코드들 다시 병합
				(5) 정렬 수행
				
			- 소트 버퍼는 크다고 좋은 것도 아니고 작다고 좋은 것도 아니다. 56KB ~ 1MB미만이 트랜잭션 처리용으로 가장 일반적이다.
				: 크다면 ==> 큰 메모리 공간 할당 때문에 리눅스 계열의 운영체제에서는 성능이 훨씬 떨어질 수 있다.
					   ==>	대량의 레코드를 정렬하는 쿼리가 여러 커넥션에서 동시실행 
							> 정렬작업이 많아져 소트 버퍼로 소비되는 메모리 공간 커짐 
							> 서버 메모리 공간 부족 ( 공간을 10MB 이상 설정시 )
							오히려 빠른 성능 기대X. 그러나 디스크의 읽기&쓰기 사용량 줄일 수 있기 때문에
							MySQL서버의 데이터가 많거나 디스크의 I/O성능이 낮으면 크게 설정하는 게 도움이 될수있다.
				: 작다면 ==> 작업하다가 여유공간이 없어서 운영체제의 OOM=KILLER가 여유공간 확보를 위해 프로세스 강제종료
				
				: 대량의 데이터 정렬이 필요한 경우 ==> 해당 세션의 소트 버퍼만 일시적으로 늘려서 쿼리를 실행 시킨 후 다시 줄이기
		
		4) 정렬 알고리즘
			: 옵티마이저 트레이스 기능을 통해 알고리즘 사용모드 파악가능
			1) 싱글 패스 
				- 레코드 전체를 소트 버퍼에 담는 경우
				- <sort_key, additional_fields> 방식
					: sort_key와 레코드 전체를 가져와서 정렬하는데 이때 레코드 칼럼을 고정 사이즈로 설정해 메모리 저장
				- <sort_key, packed_additional_fields> 방식
					: sort_key와 레코드 전체를 가져와서 정렬하는데 이때 레코드 칼럼을 가변 사이즈로 설정해 메모리 저장
				- 소트 버퍼에 정렬 기준 칼럼을 포함한 SELECT 대상이 되는 칼럼 전부를 담아 정렬	
				- 정렬 후 정렬 버퍼의 내용을 그대로 클라이언트로 넘겨준다.	
				- 대부분 해당 방법을 사용
				- 정렬 대상 레코드 크기& 건수가 작은경우 효율적이다.
			
			2) 투 패스
				- 정렬 기준 칼럼과 PK만 소트 버퍼에 담는 경우
				- <sort_key, rowid> 방식
					: 위 2개만을 이용해 정렬하는 방식
				- 소트 버퍼에 담아 위 두개의 키를 기준으로 정렬을 수행한 후 
					한번 더 테이블을 읽는데 이때 정렬된 순서대로 PK키를 기준으로 테이블을 읽어서
					다른 칼럼을 가져오고 그 결과를 클라이언트로 넘긴다. 
				- 이 과정에서 테이블을 두 번 읽게된다. 그래서 요즘에는 싱글패스를 사용.
				- 그러나 특정 조건에서만 해당 방법을 사용하는데
					1) 레코드 크기 > MAX_LENGTH_FOR_SORT_DATA 시스템 변수 설정 값
					2) SELECT 대상에 BLOB, TEXT타입이 있는 경우
				- 정렬 대상 레코드의 크기& 건수가 많은 경우 효율적이다.
			
			: SELECT * 을 이용해 모든 칼럼을 가져오게 되면 임시 테이블까지 영향을 끼치니 필요한 칼럼만 조회하도록 하자.
			
		5) 정렬 처리 방법
			: 옵티마이저가 고려하는 순서
				1) 인덱스 사용
					- ORDER BY의 순서대로 생성된 인덱스와, ORDER BY에 명시된 칼럼이 제일 먼저 읽는 테이블에 속해야 한다.
					- B_Treer게열의 인덱스가 아닌경우 해당 방법사용불가
					- 여러 테이블이 조인되는 경우 네스티드 루프 방식의 조인에서만 이 방식 이용
					- 이미 인덱스의 값이 정렬되어 있기 때문에 엔진에서 별도로 정렬을 위한 추가 작업을 하지 않는다. 
						그렇다고 해서 일부러 ORDER BY의 정렬을 제거하지는 말자.
					- 조인이 사용된 쿼리의 실행계획에 조인 버퍼가 사용된 경우 순서가 흐트려지니 주의할 것.
				2) 조인에서 드라이빙 테이블(조인에서 첫 번째로 읽히는 테이블)만 정렬
					- Filesort이용. USING FILESORT 메시지가 EXTRA칼럼에 표시된다.
					- 드라이빙 테이블의 칼럼만으로 ORDER BY절 작성
						(옵티마이저가 드라이빙 테이블만 검색해서 정렬을 먼저 수행하기 때문)
					- 드라이빙 테이블을 이용한 정렬과정
							1) 인덱스를 이용해 조건에 만족하는 레코드 검색
							2) Filesort이용해서 드라이빙 테이블에 속하는 칼럼으로 정렬수행
							3) 다른 테이블과의 조인 수행하며 최종결과 출력
				3) 조인에서 조인결과 임시 테이블로 저장 후 정렬
					- Filesort이용. USING TEMPORARY; USING FILESORT 메시지가 EXTRA칼럼에 표시된다. 
					- 정렬해야 할 레코드 건수가 많은 경우 사용하는 가장 느린 정렬 방법
					- 조인된 데이터를 가지고 정렬
			
			: 쿼리에서 인덱스를 사용하지 못하는 정렬이나 그루핑 작업이 느리게 작동하는 경우를 위한 쿼리처리 방법
				1) 스트리밍 처리
					- 조건에 일치하는 레코드가 검색될때마다 클라이언트로 즉시전송해주는 방식
					- 건수를 제한하는 LIMIT조건을 사용하는 경우에 유리
					- 어떤 클라이언트 도구나 API를 사용하느냐에 따라 방식의 차이가 있다.
						MySQL서버에서 스트리밍 처리해서 반환하더라도 
						클라이언트쪽의 JDBC 라이브러리가 버퍼링방식으로 내부 버퍼에 담았다가 
						클라이언트의 애플리케이션에 반환하기 때문이다.
						(JDBC의 버퍼링 처리 방식이 디폴트이기 때문이며 이때는 전송방식을 스트리밍으로 변경가능하다)
					- 인덱스를 사용한 정렬방식이 여기에 해당
				2) 버퍼링 처리
					- ORDER BY & GROUP BY처리할 때 사용가능. 
					 (조건에 일치하는 모든 레코드를 가져온 후 정렬&그루핑해서 보내야 하기 때문에 스트리밍 방식으로 처리불가)
					- Filesort를 이용하는 정렬방식이 여기에 해당
			
			: 정렬 관련 상태 변수
				- 실행횟수를 상태 변수로 저장
				- Sort_scan : 풀 테이블 스캔을 몇번 했는지를 저장하는 상태 변수
				- Sort_merge_passes : 단위 정렬 작업의 얼마나 했는지를 저장하는 상태 변수
				- Sort_rows : 전체 정렬된레코드 건수를 저장하는 상태 변수
		
	2. GROUP BY처리
		- HAVING절은 GROUP BY 결과를 필터링 하는 역할. 
		  어차피 인덱스 정렬방식 사용못하기 때문에 HAVING절을 위한 인덱스생성방식이나 튜닝을 고민할 필요없다.
		
		(1) 인덱스를 사용하는 경우
			1) 타이트 인덱스 스캔
				- 인덱스를 순차적으로 읽는 인덱스 스캔 방법
				- 칼럼으로 이미 인덱스가 존재하는 경우 그 인덱스를 순차적으로 읽으면서 그루핑 수행 후 조인
				- 그룹 함수의 그룹값 처리때문에 임시테이블 사용하는 경우 존재
			2) 루스 인덱스 스캔
				- 인덱스의 레코드를 건너뛰면서 필요한 부분만 읽어 가져온다. 
				- 인덱스의 유니크한 값의 수가 적을수록 성능이 향상
				- 분포도가 좋지 않은 인덱스일수록 유리한 스캔
				- 집합함수를 사용하는 경우, SELECT절 칼럼과 GROUP BY칼럼이 일치하지 않는경우 사용불가
		
		(2) 인덱스를 사용하지 못하는 경우
			1) 임시 테이블 사용
				- 인덱스를 전혀 사용하지 못하는 경우
				- GROUP BY가 필요한 경우 해당 절의 칼럼들로 구성된 유니크 인덱스를 가진 임시 테이블을 만듦
					그리고 중복 제거와 집합 함수 연산을 수행. 
					그리고 조인결과를 한건 씩 가져와 임시테이블에서 중복체크 하면서 ISNERT,UPDATE 실행
					별도의 정렬없이 처리한다.
				
	3. DISTINCT 처리
		(1) SELECT절 ( 집합 함수가 없는 경우 )
			- GROUP BY와 동일한 방식으로 처리
			- SELECT하는 레코드를 유니크하게 선택하는거지 특정칼럼만 유니크하게 조회하는 것이 아니다.
		(2) 집합함수와 함께 사용
			- DISTINCT처리가 인덱스를 사용하지 못할 때 임시 테이블이 필요하나, EXTRA칼럼에 해당 메시지가 표시되지 않는다.
			- 집합함수를 사용하는 칼럼값이 유니크한 것들을 가져온다.
			- 인덱스된 칼럼을 처리할때는 인덱스를 풀 스캔하거나 레인지 스캔하기 때문에 임시 테이블 없이 수행한다.
	
	4. 내부 임시 테이블 활용
		- 내부적인 임시 테이블 != CREATE TEMPORARY TABLE 명령으로 생성한 테이블
		- 쿼리의 처리가 완료되면 자동으로 삭제. 사용자가 접근 불가. 
		
		- 관련 시스템 변수
			* INTERNAL_TMP_STORAGE_ENGINE : MEMORY 또는 TEMP TABLE(디폴트옵션) 선택가능
			* TEMPTABLE_MAX_RAM : TEMP TABLE의 최대 사용가능한 메모리 공간 크기 제어. 기본 1GB.
			* CREATED_TEMP_TABLES : 쿼리처리를 위해 만들어진 내부 임시 테이블의 개수의 누적값 표시. 테이블이 메모리에 만들어지든 디스크에 만들어지든 다 누적해서 카운트한다.
			* CREATED_TMP_DIS_TABLES : 디스크에 내부 임시 테이블이 만들어진 개수만 누적해서 표시.
		
		(1) 메모리 임시 테이블
			- TEMPTABLE이라는 스토리지 엔진 사용. 가변 길이 타입 지원.
			- 메모리 임시 테이블 크기가 1GB보다 커지는 경우 메모리의 임시 테이블을 디스크로 기록하는데 이떄 아래의 방식 중 하나를 선택한다.
				이떄 TEMPABLE_USE_MMAP 시스템 변수로 방식을 선택한다. 그리고 디스크에 생서된 임시테이블은 TMPDIR시스템 변수에 정의된 디렉토리에 저장된다.
				1) MMAP 파일로 디스크에 기록 (디폴트옵션)
					: 2번쨰 방법보다 오버헤드가 적어서 기본값으로 설정되어 있다.
				2) InnoDB테이블로 기록
			- 위의 방법으로 생성된 임시테이블은 파일오픈 후 파일삭제를 실행하기 때문에 운영체제에서 명령어로 확인이 불가하다. 조회해봤자 DELETED로 표시될거니까.
			
		(2) 디스크 임시 테이블
			- InnoDB 스토리지 엔진 사용. 트랜잭션 지원.
			- INTERNAL_TMP_STORAGE_ENGINE 설정된 스토리지 엔진 사용.
		
			- 임시 테이블이 필요한 쿼리 ( 유니크 인덱스를 가지는 내부 임시 테이블 생성 )
				* ORDER BY 명시 컬럼 != GROUP BY 명시 컬럼
				* ORDER BY, GROUP BY 명시 컬럼이 조인 순서상 첫번째 테이블이 아닌경우
				
				: 아래 4가지 경우는 EXTRA칼럼에 USING TEMPORARY 메시지는 표시되지 않지만 임시테이블 사용
				* DISTINCT, ORDER BY 동시에 사용하는 경우
				* DISTINCT가 인덱스로 처리되지 못하는 경우
				* UNION 또는 DISTINCT가 사용된 쿼리 ( 임시 테이블을 이용한 중복 제거 작업 필수 )
				* SELECT_TYPE이 DERIVED인 쿼리 ( 유니크 인덱스가 없는 내부 임시 테이블이 생성. 처리성능 느리다 )
				
			- 임시 테이블이 디스크에 생성되는 경우	
				* UNION, UNION ALL에서 SELECT되는 칼럼,
				  GROUP BY, DISTINCT 칼럼의 길이가 512바이트 이상인 경우
				* 메모리 임시테이블의 크기가 TEMPTABLE_MAX_RAM에서 설정한 변수 값보다 큰 경우
				* MEMORY 스토리지 엔진을 사용하는 경우
				
			
